"use strict";
// ---------- WARN! DO NOT EDIT BY HAND. THIS FILE IS AUTOMATICALLY GENERATED BY firebase-orm. ---------- 
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildEntity = exports.RelationNotFoundError = exports.FirestoreReference = exports.SnapShotBox = exports.documentReferencePath = void 0;
// ---------- WARN! DO NOT EDIT BY HAND. THIS FILE IS AUTOMATICALLY GENERATED BY firebase-orm. ---------- 
const Entity_1 = require("./Entity");
const Repository_1 = require("./Repository");
const type_mapper_1 = require("./type-mapper");
exports.documentReferencePath = '__firestore_document_reference__';
function isBrowserOptimizedDocumentSnapshot(snapshot) {
    return snapshot.data && "exists" in snapshot;
}
function isBrowserOptimizedQuerySnapshot(snapshot) {
    return snapshot.docs && "size" in snapshot;
}
function isBrowserOptimizedDocumentReference(snapshot) {
    return snapshot.set && snapshot.delete && snapshot.get;
}
class SnapShotBox {
    constructor(snapshot) {
        this.snapshot = snapshot;
    }
    unbox() {
        if (this.snapshot instanceof type_mapper_1.firestore.DocumentSnapshot || isBrowserOptimizedDocumentSnapshot(this.snapshot)) {
            const snapshot = this.snapshot;
            if (!snapshot.exists) {
                return null;
            }
            return [Object.assign({ id: snapshot.id, [exports.documentReferencePath]: snapshot.ref }, snapshot.data())];
        }
        else if (this.snapshot instanceof type_mapper_1.firestore.QuerySnapshot || isBrowserOptimizedQuerySnapshot(this.snapshot)) {
            if (this.snapshot.size == 0) {
                return [];
            }
            return this.snapshot.docs.map(x => {
                return Object.assign({ id: x.id, [exports.documentReferencePath]: x.ref }, x.data());
            });
        }
        return null;
    }
}
exports.SnapShotBox = SnapShotBox;
class FirestoreReference {
    constructor(ref, transaction) {
        this.ref = ref;
        this.transaction = transaction;
    }
    get() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.transaction) {
                const box = new SnapShotBox(yield this.transaction.get(this.ref));
                return box;
            }
            else {
                return new SnapShotBox(yield this.ref.get());
            }
        });
    }
    set(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ref instanceof type_mapper_1.firestore.DocumentReference || isBrowserOptimizedDocumentReference(this.ref)) {
                const ref = this.ref;
                if (this.transaction) {
                    this.transaction.set(ref, params);
                    return;
                }
                else {
                    yield ref.set(params);
                    return;
                }
            }
            throw new Error('reference should be DocumentReference');
        });
    }
    update(params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ref instanceof type_mapper_1.firestore.DocumentReference || isBrowserOptimizedDocumentReference(this.ref)) {
                const ref = this.ref;
                if (this.transaction) {
                    this.transaction.update(ref, params);
                    return;
                }
                else {
                    yield ref.update(params);
                    return;
                }
            }
            throw new Error('reference should be DocumentReference');
        });
    }
}
exports.FirestoreReference = FirestoreReference;
class RelationNotFoundError extends Error {
    constructor(relation) {
        super(`relation ${relation} is not exists.`);
        this.relation = relation;
        this.name = 'RelationNotFoundError';
        Object.setPrototypeOf(this, RelationNotFoundError.prototype);
    }
    toString() {
        return this.name + ': ' + this.message;
    }
}
exports.RelationNotFoundError = RelationNotFoundError;
function relationToGroup(relations) {
    const grouped = {};
    for (const relation of relations) {
        const comp = relation.split('.');
        if (comp.length == 1) {
            if (!grouped[comp[0]]) {
                grouped[comp[0]] = {};
            }
        }
        else {
            const top = comp.shift();
            if (!grouped[top]) {
                grouped[top] = {};
            }
            Object.assign(grouped[top], relationToGroup([comp.join('.')]));
        }
    }
    return grouped;
}
function groupToRelation(grouped) {
    const keys = [];
    for (const key in grouped) {
        let relationKey = key;
        const childKey = groupToRelation(grouped[key])[0];
        if (childKey) {
            relationKey += '.' + childKey;
        }
        keys.push(relationKey);
    }
    return keys;
}
function hasOwnProperty(obj, prop) {
    return obj.hasOwnProperty(prop);
}
function getName(setting) {
    if (!setting.option) {
        return undefined;
    }
    if (hasOwnProperty(setting.option, 'name')) {
        return setting.option.name;
    }
    return undefined;
}
function buildEntity(meta, data, reference, options) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const groupedRelations = (options === null || options === void 0 ? void 0 : options.relations) ? relationToGroup(options.relations) : {};
        const plain = {};
        for (const relation of Object.keys(groupedRelations)) {
            if (!meta.columns.map(x => x.propertyKey).includes(relation)) {
                throw new RelationNotFoundError(relation);
            }
        }
        for (const setting of meta.columns) {
            let keyInForestore = getName(setting) || setting.propertyKey;
            if (setting instanceof Entity_1._ManyToOneSetting) {
                const relation = groupedRelations[setting.propertyKey];
                if (!relation) {
                    continue;
                }
                if ((_a = setting.option) === null || _a === void 0 ? void 0 : _a.joinColumnName) {
                    keyInForestore = setting.option.joinColumnName;
                }
                const rawRef = data[keyInForestore];
                const hierarchy = yield followHierarchy({
                    setting: setting,
                    relations: {
                        top: setting.propertyKey,
                        hierarchy: relation
                    },
                    reference: reference,
                    fetchMode: {
                        mode: 'ref',
                        reference: rawRef
                    }
                });
                Object.assign(plain, hierarchy);
            }
            else if (setting instanceof Entity_1._OneToManySetting) {
                const relation = groupedRelations[setting.propertyKey];
                if (!relation) {
                    continue;
                }
                const hierarchy = yield followHierarchy({
                    setting: setting,
                    relations: {
                        top: setting.propertyKey,
                        hierarchy: relation
                    },
                    reference: reference,
                    fetchMode: {
                        mode: 'many'
                    }
                });
                Object.assign(plain, hierarchy);
            }
            else if (setting instanceof Entity_1._OneToOneSetting) {
                const relation = groupedRelations[setting.propertyKey];
                if (!relation) {
                    continue;
                }
                if ((_b = setting.option) === null || _b === void 0 ? void 0 : _b.joinColumnName) {
                    keyInForestore = setting.option.joinColumnName;
                    const rawRef = data[keyInForestore];
                    const hierarchy = yield followHierarchy({
                        setting: setting,
                        relations: {
                            top: setting.propertyKey,
                            hierarchy: relation
                        },
                        reference: reference,
                        fetchMode: {
                            mode: 'ref',
                            reference: rawRef
                        }
                    });
                    Object.assign(plain, hierarchy);
                }
                else if ((_c = setting.option) === null || _c === void 0 ? void 0 : _c.relationColumn) {
                    const hierarchy = yield followHierarchy({
                        setting: setting,
                        relations: {
                            top: setting.propertyKey,
                            hierarchy: relation
                        },
                        reference: reference,
                        fetchMode: {
                            mode: 'single',
                            reference: data[exports.documentReferencePath]
                        }
                    });
                    Object.assign(plain, hierarchy);
                }
            }
            else if (setting instanceof Entity_1._ArrayReference) {
                const relation = groupedRelations[setting.propertyKey];
                if (!relation) {
                    continue;
                }
                const hierarchy = yield followHierarchy({
                    setting: setting,
                    relations: {
                        top: setting.propertyKey,
                        hierarchy: relation
                    },
                    reference: reference,
                    fetchMode: {
                        mode: 'array',
                        references: data[keyInForestore]
                    }
                });
                Object.assign(plain, hierarchy);
            }
            else {
                plain[setting.propertyKey] = data[keyInForestore];
            }
        }
        const instance = new meta.Entity();
        for (const key in plain) {
            instance[key] = plain[key];
        }
        instance[exports.documentReferencePath] = data[exports.documentReferencePath];
        return instance;
    });
}
exports.buildEntity = buildEntity;
function followHierarchy(params) {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
        const results = {};
        switch (params.fetchMode.mode) {
            case 'ref':
                const ref = new FirestoreReference(params.fetchMode.reference, (_a = params.reference) === null || _a === void 0 ? void 0 : _a.transaction);
                const box = yield ref.get();
                const unboxed = box.unbox();
                if (unboxed && unboxed[0]) {
                    const meta = (0, Entity_1.findMeta)(params.setting.getEntity());
                    results[params.setting.propertyKey] = yield buildEntity(meta, unboxed[0], ref, { relations: groupToRelation(params.relations.hierarchy || {}) });
                }
                break;
            case 'single':
                const singleRef = params.fetchMode.reference;
                const singlRepo = (0, Repository_1.getRepository)(params.setting.getEntity());
                if ((_b = params.reference) === null || _b === void 0 ? void 0 : _b.transaction) {
                    singlRepo.setTransaction(params.reference.transaction);
                }
                results[params.setting.propertyKey] = yield singlRepo.prepareFetcher(db => {
                    return db.where(params.setting.option.relationColumn, '==', singleRef);
                }).fetchOne({
                    relations: groupToRelation(params.relations.hierarchy || {})
                });
                break;
            case 'many':
                const manyRepo = (0, Repository_1.getRepository)(params.setting.getEntity());
                if ((_c = params.reference) === null || _c === void 0 ? void 0 : _c.transaction) {
                    manyRepo.setTransaction((_d = params.reference) === null || _d === void 0 ? void 0 : _d.transaction);
                }
                results[params.setting.propertyKey] = yield manyRepo.prepareFetcher(db => {
                    var _a;
                    return db.where(params.setting.option.relationColumn, '==', (_a = params.reference) === null || _a === void 0 ? void 0 : _a.ref);
                }).fetchAll({
                    relations: groupToRelation(params.relations.hierarchy || {})
                });
                break;
            case 'array':
                const refs = params.fetchMode.references.map(ref => { var _a; return new FirestoreReference(ref, (_a = params.reference) === null || _a === void 0 ? void 0 : _a.transaction); });
                results[params.setting.propertyKey] = yield Promise.all(refs.map(ref => {
                    return ref.get().then(box => {
                        const unboxed = box.unbox();
                        if (unboxed && unboxed[0]) {
                            const meta = (0, Entity_1.findMeta)(params.setting.getEntity());
                            return buildEntity(meta, unboxed[0], ref, { relations: groupToRelation(params.relations.hierarchy || {}) });
                        }
                        return null;
                    });
                }));
                break;
        }
        return results;
    });
}
//# sourceMappingURL=EntityBuilder.js.map