"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
const admin = require("firebase-admin");
const Repository_1 = require("../Repository");
const User_1 = require("../examples/entity/User");
const ArticleStat_1 = require("../examples/entity/ArticleStat");
const Article_1 = require("../examples/entity/Article");
const Category_1 = require("../examples/entity/Category");
const chai_1 = require("chai");
const events_1 = require("events");
const ArticleComment_1 = require("../examples/entity/ArticleComment");
const __1 = require("..");
const Error_1 = require("../Error");
const ArticleCommentLike_1 = require("../examples/entity/ArticleCommentLike");
const child_process_1 = require("child_process");
const Entity_1 = require("../Entity");
const serviceAccount = require("../../polyrhythm-dev-example-firebase-adminsdk-ed17d-272223a77d.json");
admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    databaseURL: `https://${serviceAccount.project_id}.firebaseio.com`
});
const db = admin.firestore();
function getRandomIntString(max = 1000) {
    return Math.floor(Math.random() * Math.floor(max)).toString();
}
(0, Repository_1.addDBToPool)('default', db);
(0, Repository_1.use)('default');
function deleteAllData(Entity) {
    return __awaiter(this, void 0, void 0, function* () {
        (0, child_process_1.execSync)(`firebase firestore:delete ${(0, Entity_1.findMeta)(Entity).tableName} -r --project ${serviceAccount.project_id} -y`);
    });
}
function cleanTables() {
    return __awaiter(this, void 0, void 0, function* () {
        yield deleteAllData(User_1.User);
        yield deleteAllData(Article_1.Article);
        yield deleteAllData(ArticleStat_1.ArticleStat);
        yield deleteAllData(Category_1.Category);
    });
}
describe('Repository test', () => __awaiter(void 0, void 0, void 0, function* () {
    before(() => __awaiter(void 0, void 0, void 0, function* () {
    }));
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        yield cleanTables();
    }));
    afterEach(() => __awaiter(void 0, void 0, void 0, function* () {
    }));
    after(() => __awaiter(void 0, void 0, void 0, function* () {
    }));
    context('AutoGenerated ID', () => {
        it('should attach autogenerated id to the resource if the id is not provided', () => __awaiter(void 0, void 0, void 0, function* () {
            const user = new User_1.User();
            user.name = 'hoge';
            yield (0, Repository_1.getRepository)(User_1.User).save(user);
            (0, chai_1.expect)(user.id).to.not.undefined;
            (0, chai_1.expect)(user.id).to.not.null;
            (0, chai_1.expect)(user.id).to.not.empty;
        }));
    });
    context('simple CRUD', () => {
        it("should perform simple CRUD", () => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const repo = (0, Repository_1.getRepository)(User_1.User);
            // create
            const user = new User_1.User();
            user.id = getRandomIntString();
            user.name = 'test-user';
            user.age = 30;
            yield repo.save(user);
            // fetch
            (0, chai_1.expect)((_a = (yield repo.fetchOneById(user.id))) === null || _a === void 0 ? void 0 : _a.id).eq(user.id);
            // partial fields update
            yield repo.update(user, {
                name: 'updated'
            });
            const fetched = yield repo.fetchOneById(user.id);
            (0, chai_1.expect)(fetched === null || fetched === void 0 ? void 0 : fetched.name).eq('updated');
            (0, chai_1.expect)(fetched === null || fetched === void 0 ? void 0 : fetched.age).eq(30); // keep old
            // delete
            yield repo.delete(user);
            (0, chai_1.expect)((yield repo.fetchOneById(user.id))).to.be.null;
        }));
        it("should update value as null", () => __awaiter(void 0, void 0, void 0, function* () {
            const repo = (0, Repository_1.getRepository)(User_1.User);
            // create
            const user = new User_1.User();
            user.id = getRandomIntString();
            user.name = 'test-user';
            user.age = 30;
            user.description = "this is test";
            yield repo.save(user);
            yield repo.update(user, {
                description: null
            });
            (0, chai_1.expect)(user.description).to.be.null;
        }));
    });
    context('relations', () => {
        it("Many to One", () => __awaiter(void 0, void 0, void 0, function* () {
            const article = yield (0, Repository_1.runTransaction)((manager) => __awaiter(void 0, void 0, void 0, function* () {
                const user = new User_1.User();
                user.id = getRandomIntString();
                user.name = 'test-user';
                yield manager.getRepository(User_1.User).save(user);
                const article = new Article_1.Article();
                article.id = getRandomIntString();
                article.title = 'title';
                article.contentText = 'bodybody';
                article.user = user;
                yield manager.getRepository(Article_1.Article).save(article);
                return article;
            }));
            const item = yield (0, Repository_1.getRepository)(Article_1.Article).fetchOneById(article.id, {
                relations: ['user']
            });
            (0, chai_1.expect)(item === null || item === void 0 ? void 0 : item.id).eq(article.id);
            (0, chai_1.expect)(article === null || article === void 0 ? void 0 : article.user.id).eq(article.user.id);
        }));
        it("One to One", () => __awaiter(void 0, void 0, void 0, function* () {
            const article = yield (0, Repository_1.runTransaction)((manager) => __awaiter(void 0, void 0, void 0, function* () {
                const stat = new ArticleStat_1.ArticleStat();
                stat.id = getRandomIntString();
                stat.numOfViews = 10000;
                yield manager.getRepository(ArticleStat_1.ArticleStat).save(stat);
                const article = new Article_1.Article();
                article.id = getRandomIntString();
                article.title = 'title';
                article.contentText = 'bodybody';
                article.stat = stat;
                yield manager.getRepository(Article_1.Article).save(article);
                return article;
            }));
            const item = yield (0, Repository_1.getRepository)(Article_1.Article).fetchOneById(article.id, {
                relations: ['stat']
            });
            (0, chai_1.expect)(item === null || item === void 0 ? void 0 : item.id).eq(article.id);
            (0, chai_1.expect)(article === null || article === void 0 ? void 0 : article.stat.id).eq(article.stat.id);
        }));
        it("One to Many", () => __awaiter(void 0, void 0, void 0, function* () {
            const article = yield (0, Repository_1.runTransaction)((manager) => __awaiter(void 0, void 0, void 0, function* () {
                const user = new User_1.User();
                user.id = getRandomIntString();
                user.name = 'test-user';
                yield manager.getRepository(User_1.User).save(user);
                const article = new Article_1.Article();
                article.id = getRandomIntString();
                article.title = 'title';
                article.contentText = 'bodybody';
                article.user = user;
                yield manager.getRepository(Article_1.Article).save(article);
                return article;
            }));
            const user = yield (0, Repository_1.getRepository)(User_1.User).fetchOneById(article.user.id, {
                relations: ['articles']
            });
            (0, chai_1.expect)(user === null || user === void 0 ? void 0 : user.id).eq(article.user.id);
            (0, chai_1.expect)(user === null || user === void 0 ? void 0 : user.articles[0].id).eq(article.id);
        }));
        it("ArrayreReference", () => __awaiter(void 0, void 0, void 0, function* () {
            const user = new User_1.User();
            user.id = getRandomIntString();
            user.name = 'test-user';
            yield (0, Repository_1.getRepository)(User_1.User).save(user);
            const category = new Category_1.Category();
            category.id = getRandomIntString();
            category.name = 'math';
            yield (0, Repository_1.getRepository)(Category_1.Category).save(category);
            const article = new Article_1.Article();
            article.id = getRandomIntString();
            article.title = 'title';
            article.contentText = 'bodybody';
            article.user = user;
            article.categories = [category];
            yield (0, Repository_1.getRepository)(Article_1.Article).save(article);
            const result = yield (0, Repository_1.getRepository)(Article_1.Article).prepareFetcher(db => {
                return db.where('categories', 'array-contains', (0, __1.PureReference)(category));
            }).fetchAll({
                relations: ['categories']
            });
            (0, chai_1.expect)(result[0].categories[0].id).eq(category.id);
        }));
        it("should fetch nested relation data", () => __awaiter(void 0, void 0, void 0, function* () {
            const userId = yield (0, Repository_1.runTransaction)((manager) => __awaiter(void 0, void 0, void 0, function* () {
                const user = new User_1.User();
                user.id = getRandomIntString();
                user.name = 'test-user';
                yield manager.getRepository(User_1.User).save(user);
                const category = new Category_1.Category();
                category.id = getRandomIntString();
                category.name = 'math';
                yield manager.getRepository(Category_1.Category).save(category);
                const article = new Article_1.Article();
                article.id = getRandomIntString();
                article.title = 'title';
                article.contentText = 'bodybody';
                article.user = user;
                article.categories = [category];
                yield manager.getRepository(Article_1.Article).save(article);
                const articleStat = new ArticleStat_1.ArticleStat();
                articleStat.id = getRandomIntString();
                articleStat.article = article;
                articleStat.numOfViews = 100;
                yield manager.getRepository(ArticleStat_1.ArticleStat).save(articleStat);
                return user.id;
            }));
            const user = yield (0, Repository_1.getRepository)(User_1.User).fetchOneById(userId, {
                relations: ['articles.categories', 'articles.stat']
            });
            (0, chai_1.expect)(user === null || user === void 0 ? void 0 : user.articles.length).eq(1);
            (0, chai_1.expect)(user === null || user === void 0 ? void 0 : user.articles[0]).haveOwnProperty('stat');
            (0, chai_1.expect)(user === null || user === void 0 ? void 0 : user.articles[0]).haveOwnProperty('categories');
        }));
        it("fetchOneByIdOrFail", () => __awaiter(void 0, void 0, void 0, function* () {
            var _a;
            const repo = (0, Repository_1.getRepository)(User_1.User);
            // create
            const user = new User_1.User();
            user.id = getRandomIntString();
            user.name = 'test-user';
            yield repo.save(user);
            // fetch
            (0, chai_1.expect)((_a = (yield repo.fetchOneByIdOrFail(user.id))) === null || _a === void 0 ? void 0 : _a.id).eq(user.id);
            try {
                yield repo.fetchOneByIdOrFail("100000000000000");
                throw new Error('never reached here.');
            }
            catch (e) {
                (0, chai_1.expect)(e).instanceOf(Error_1.RecordNotFoundError);
            }
        }));
    });
    context('transactions', () => {
        it("should update resource partially", () => __awaiter(void 0, void 0, void 0, function* () {
            const user = yield (0, Repository_1.runTransaction)((manager) => __awaiter(void 0, void 0, void 0, function* () {
                const user = new User_1.User();
                user.id = getRandomIntString();
                user.name = 'test-user';
                user.age = 30;
                yield manager.getRepository(User_1.User).save(user);
                yield manager.getRepository(User_1.User).update(user, {
                    name: 'updated'
                });
                return user;
            }));
            const fetched = yield (0, Repository_1.getRepository)(User_1.User).fetchOneById(user.id);
            (0, chai_1.expect)(fetched === null || fetched === void 0 ? void 0 : fetched.name).eq('updated');
            (0, chai_1.expect)(fetched === null || fetched === void 0 ? void 0 : fetched.age).eq(30); // keep old
        }));
        it("should rollback creation", () => __awaiter(void 0, void 0, void 0, function* () {
            try {
                yield (0, Repository_1.runTransaction)((manager) => __awaiter(void 0, void 0, void 0, function* () {
                    const user = new User_1.User();
                    user.id = getRandomIntString();
                    user.name = 'test-user';
                    yield manager.getRepository(User_1.User).save(user);
                    const article = new Article_1.Article();
                    article.id = getRandomIntString();
                    article.title = 'title';
                    article.contentText = 'bodybody';
                    article.user = user;
                    yield manager.getRepository(Article_1.Article).save(article);
                    throw new Error('rollback');
                }));
            }
            catch (e) {
                const users = yield (0, Repository_1.getRepository)(User_1.User).fetchAll();
                const articles = yield (0, Repository_1.getRepository)(Article_1.Article).fetchAll();
                (0, chai_1.expect)(users.length).eq(0);
                (0, chai_1.expect)(articles.length).eq(0);
            }
        }));
        it("should rollback deletion", () => __awaiter(void 0, void 0, void 0, function* () {
            const userId = getRandomIntString();
            const user = new User_1.User();
            user.id = userId;
            user.name = 'test-user';
            yield (0, Repository_1.getRepository)(User_1.User).save(user);
            try {
                yield (0, Repository_1.runTransaction)((manager) => __awaiter(void 0, void 0, void 0, function* () {
                    const user = yield manager.getRepository(User_1.User).fetchOneById(userId);
                    yield manager.getRepository(User_1.User).delete(user);
                    throw new Error('rollback');
                }));
            }
            catch (e) {
                const user = yield (0, Repository_1.getRepository)(User_1.User).fetchOneById(userId);
                (0, chai_1.expect)(user === null || user === void 0 ? void 0 : user.id).eq(userId);
            }
        }));
    });
    context('nestedCollection', () => {
        it("should perform curd for nested collection", () => __awaiter(void 0, void 0, void 0, function* () {
            const result = yield (0, Repository_1.runTransaction)((manager) => __awaiter(void 0, void 0, void 0, function* () {
                const user = new User_1.User();
                user.id = getRandomIntString();
                user.name = 'test-user';
                yield manager.getRepository(User_1.User).save(user);
                const article = new Article_1.Article();
                article.id = getRandomIntString();
                article.title = 'title';
                article.contentText = 'bodybody';
                article.user = user;
                yield manager.getRepository(Article_1.Article).save(article);
                const articleComment = new ArticleComment_1.ArticleComment();
                articleComment.id = getRandomIntString();
                articleComment.text = 'hello';
                yield manager.getRepository(ArticleComment_1.ArticleComment, { parentIdMapper: (Entity) => {
                        switch (Entity) {
                            case Article_1.Article:
                                return article.id;
                        }
                        throw new Error(`Unknonwn Entity ${Entity.name}`);
                    } }).save(articleComment);
                return [article, articleComment];
            }));
            const article = result[0];
            const commentRepo = (0, Repository_1.getRepository)(ArticleComment_1.ArticleComment, { parentIdMapper: (Entity) => {
                    switch (Entity) {
                        case Article_1.Article:
                            return article.id;
                    }
                    throw new Error(`Unknonwn Entity ${Entity.name}`);
                } });
            let comments = yield commentRepo.fetchAll();
            (0, chai_1.expect)(comments.length).eq(1);
            let comment = comments[0];
            comment.text = 'updated';
            yield commentRepo.save(comment);
            comments = yield commentRepo.fetchAll();
            comment = comments[0];
            (0, chai_1.expect)(comment.text).eq("updated");
            const likeRepo = yield (0, Repository_1.getRepository)(ArticleCommentLike_1.ArticleCommentLike, { parentIdMapper: (Entity) => {
                    switch (Entity) {
                        case Article_1.Article:
                            return article.id;
                        case ArticleComment_1.ArticleComment:
                            return comment.id;
                    }
                    throw new Error(`Unknonwn Entity ${Entity.name}`);
                } });
            const like = new ArticleCommentLike_1.ArticleCommentLike();
            like.count = 100;
            yield likeRepo.save(like);
            let likes = yield likeRepo.fetchAll();
            (0, chai_1.expect)(likes.length).eq(1);
            /**
             * Delete
             */
            yield likeRepo.delete(like);
            likes = yield likeRepo.fetchAll();
            (0, chai_1.expect)(likes.length).eq(0);
            yield commentRepo.delete(comment);
            comments = yield commentRepo.fetchAll();
            (0, chai_1.expect)(comments.length).eq(0);
        }));
    });
    context('Multiple connections', () => {
        function saveTestData(repos) {
            return __awaiter(this, void 0, void 0, function* () {
                let i = 1;
                for (const repo of repos) {
                    let user = new User_1.User();
                    user.id = getRandomIntString();
                    user.name = 'test-user' + i.toString();
                    user.age = 30;
                    yield repo.save(user);
                    i++;
                }
            });
        }
        it("Should perform read/write with specified db", () => __awaiter(void 0, void 0, void 0, function* () {
            (0, Repository_1.addDBToPool)('con1', db);
            (0, Repository_1.addDBToPool)('con2', db);
            const repo1 = (0, Repository_1.getRepository)(User_1.User, undefined, (0, Repository_1.takeDBFromPool)('con1'));
            const repo2 = (0, Repository_1.getRepository)(User_1.User, undefined, (0, Repository_1.takeDBFromPool)('con2'));
            yield saveTestData([repo1, repo2]);
            const results = yield Promise.all([
                repo1.fetchAll(),
                repo2.fetchAll()
            ]);
            results.forEach(r => {
                (0, chai_1.expect)(r.length).eq(2);
            });
        }));
        it("Should perform write with specified db in transaction", () => __awaiter(void 0, void 0, void 0, function* () {
            (0, Repository_1.addDBToPool)('con1', db);
            (0, Repository_1.addDBToPool)('con2', db);
            yield (0, Repository_1.runTransaction)((manager) => __awaiter(void 0, void 0, void 0, function* () {
                const repo1 = manager.getRepository(User_1.User, undefined, (0, Repository_1.takeDBFromPool)('con1'));
                const repo2 = manager.getRepository(User_1.User, undefined, (0, Repository_1.takeDBFromPool)('con2'));
                yield saveTestData([repo1, repo2]);
            }));
        }));
    });
    context('onSnapshot', () => {
        it("should sync snap shot with relations", () => __awaiter(void 0, void 0, void 0, function* () {
            const evm = new events_1.EventEmitter();
            let phase = 1;
            const unsubscribe = (0, Repository_1.getRepository)(User_1.User).prepareFetcher(db => {
                return db.limit(5);
            }).onSnapShot((result) => __awaiter(void 0, void 0, void 0, function* () {
                const type = result.type;
                switch (phase) {
                    case 1:
                        (0, chai_1.expect)(type).eq('added');
                        const user = result.item;
                        (0, chai_1.expect)(user === null || user === void 0 ? void 0 : user.articles.length).eq(1);
                        (0, chai_1.expect)(user === null || user === void 0 ? void 0 : user.articles[0]).haveOwnProperty('stat');
                        (0, chai_1.expect)(user === null || user === void 0 ? void 0 : user.articles[0]).haveOwnProperty('categories');
                        phase++;
                        evm.emit(phase.toString(), result.item);
                        break;
                    case 2:
                        (0, chai_1.expect)(type).eq('modified');
                        phase++;
                        evm.emit(phase.toString(), result.item);
                        break;
                    case 3:
                        (0, chai_1.expect)(type).eq('removed');
                        (0, chai_1.expect)(result.id).to.not.empty;
                        unsubscribe();
                        break;
                }
            }), {
                relations: ['articles.categories', 'articles.stat']
            });
            // phase 1
            yield (0, Repository_1.runTransaction)((manager) => __awaiter(void 0, void 0, void 0, function* () {
                const user = new User_1.User();
                user.id = getRandomIntString();
                user.name = 'test-user';
                yield manager.getRepository(User_1.User).save(user);
                const category = new Category_1.Category();
                category.id = getRandomIntString();
                category.name = 'math';
                yield manager.getRepository(Category_1.Category).save(category);
                const article = new Article_1.Article();
                article.id = getRandomIntString();
                article.title = 'title';
                article.contentText = 'bodybody';
                article.user = user;
                article.categories = [category];
                yield manager.getRepository(Article_1.Article).save(article);
                const articleStat = new ArticleStat_1.ArticleStat();
                articleStat.id = getRandomIntString();
                articleStat.article = article;
                articleStat.numOfViews = 100;
                yield manager.getRepository(ArticleStat_1.ArticleStat).save(articleStat);
            }));
            evm.on('2', (user) => __awaiter(void 0, void 0, void 0, function* () {
                user.name = 'updated';
                yield (0, Repository_1.getRepository)(User_1.User).save(user);
            }));
            evm.on('3', (user) => __awaiter(void 0, void 0, void 0, function* () {
                yield (0, Repository_1.getRepository)(User_1.User).delete(user);
            }));
        }));
    });
}));
//# sourceMappingURL=Repository.spec.js.map