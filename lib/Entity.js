"use strict";
// ---------- WARN! DO NOT EDIT BY HAND. THIS FILE IS AUTOMATICALLY GENERATED BY firebase-orm. ---------- 
Object.defineProperty(exports, "__esModule", { value: true });
exports.NestedFirebaseEntity = exports.FirebaseEntity = exports.AfterLoad = exports.AfterSave = exports.BeforeSave = exports.UpdateDateColumn = exports.CreateDateColumn = exports.ArrayReference = exports.ManyToOne = exports.OneToOne = exports.OneToMany = exports.Column = exports.PrimaryColumn = exports.findMetaFromTableName = exports.findMeta = exports.callHook = exports._HookFunction = exports._UpdateDateColumnSetting = exports._CreateDateColumnSetting = exports._ArrayReference = exports._ManyToOneSetting = exports._OneToOneSetting = exports._OneToManySetting = exports._ColumnSetting = exports._PrimaryColumnSetting = void 0;
// ---------- WARN! DO NOT EDIT BY HAND. THIS FILE IS AUTOMATICALLY GENERATED BY firebase-orm. ---------- 
require("reflect-metadata");
class _PrimaryColumnSetting {
    constructor(propertyKey) {
        this.propertyKey = propertyKey;
    }
}
exports._PrimaryColumnSetting = _PrimaryColumnSetting;
class _ColumnSetting {
    constructor(propertyKey, columnType, option) {
        this.propertyKey = propertyKey;
        this.columnType = columnType;
        this.option = option;
    }
}
exports._ColumnSetting = _ColumnSetting;
class _OneToManySetting {
    constructor(propertyKey, getEntity, option) {
        this.propertyKey = propertyKey;
        this.getEntity = getEntity;
        this.option = option;
    }
}
exports._OneToManySetting = _OneToManySetting;
class _OneToOneSetting {
    constructor(propertyKey, getEntity, option) {
        this.propertyKey = propertyKey;
        this.getEntity = getEntity;
        this.option = option;
    }
}
exports._OneToOneSetting = _OneToOneSetting;
class _ManyToOneSetting {
    constructor(propertyKey, getEntity, option) {
        this.propertyKey = propertyKey;
        this.getEntity = getEntity;
        this.option = option;
    }
}
exports._ManyToOneSetting = _ManyToOneSetting;
class _ArrayReference {
    constructor(propertyKey, getEntity, option) {
        this.propertyKey = propertyKey;
        this.getEntity = getEntity;
        this.option = option;
    }
}
exports._ArrayReference = _ArrayReference;
class _CreateDateColumnSetting {
    constructor(propertyKey) {
        this.propertyKey = propertyKey;
    }
}
exports._CreateDateColumnSetting = _CreateDateColumnSetting;
class _UpdateDateColumnSetting {
    constructor(propertyKey) {
        this.propertyKey = propertyKey;
    }
}
exports._UpdateDateColumnSetting = _UpdateDateColumnSetting;
class _HookFunction {
    constructor(timing, functionName) {
        this.timing = timing;
        this.functionName = functionName;
    }
}
exports._HookFunction = _HookFunction;
const hookSettings = [];
function addHooks(getEntity, hook) {
    hookSettings.push({ getEntity, hook });
}
function callHook(meta, resource, timing) {
    if (!meta.hooks) {
        return;
    }
    for (const hook of meta.hooks) {
        if (hook.timing === timing) {
            if (resource[hook.functionName]) {
                resource[hook.functionName]();
            }
            break;
        }
    }
}
exports.callHook = callHook;
const entityMetaInfo = [];
const columnSettings = [];
const entityMetaData = {};
const SYMBOL_KEY = Symbol('__firebase_orm_symbol__');
const ENTITY_META_DATA_PROP_KEY = "entityMetaData";
// having side effects getter
function findMeta(Entity) {
    const meta = Reflect.getMetadata(SYMBOL_KEY, Entity.prototype, ENTITY_META_DATA_PROP_KEY);
    if (meta) {
        return meta;
    }
    const tableInfo = entityMetaInfo.filter(x => x.Entity == Entity)[0];
    const setting = columnSettings.map(x => {
        return {
            column: x.column,
            Entity: x.getEntity()
        };
    }).filter(x => x.Entity == Entity);
    const hooks = hookSettings.filter(x => x.getEntity() == Entity).map(x => x.hook);
    const metaData = Object.assign(Object.assign({}, tableInfo), { columns: setting.map(x => x.column), hooks: hooks });
    Reflect.defineMetadata(SYMBOL_KEY, metaData, Entity.prototype, ENTITY_META_DATA_PROP_KEY);
    return metaData;
}
exports.findMeta = findMeta;
function findMetaFromTableName(tableName) {
    const index = entityMetaInfo.findIndex(x => x.tableName == tableName);
    if (index == -1) {
        return null;
    }
    const info = entityMetaInfo[index];
    const meta = Reflect.getMetadata(SYMBOL_KEY, info.Entity.prototype, ENTITY_META_DATA_PROP_KEY);
    if (meta) {
        return meta;
    }
    const setting = columnSettings.map(x => {
        return {
            column: x.column,
            Entity: x.getEntity()
        };
    }).filter(x => x.Entity == info.Entity);
    const hooks = hookSettings.filter(x => x.getEntity() == info.Entity).map(x => x.hook);
    const metaData = Object.assign(Object.assign({}, info), { columns: setting.map(x => x.column), hooks: hooks });
    Reflect.defineMetadata(SYMBOL_KEY, metaData, info.Entity.prototype, ENTITY_META_DATA_PROP_KEY);
    return metaData;
}
exports.findMetaFromTableName = findMetaFromTableName;
function addColumnSettings(getEntity, setting) {
    columnSettings.push({
        getEntity: getEntity,
        column: setting
    });
}
function PrimaryColumn() {
    return (target, propertyKey) => {
        addColumnSettings(() => target.constructor, new _PrimaryColumnSetting(propertyKey));
    };
}
exports.PrimaryColumn = PrimaryColumn;
function Column(options) {
    return (target, propertyKey) => {
        const ColumnType = Reflect.getMetadata("design:type", target, propertyKey);
        addColumnSettings(() => target.constructor, new _ColumnSetting(propertyKey, ColumnType, options));
    };
}
exports.Column = Column;
function OneToMany(getEntity, options) {
    return (target, propertyKey) => {
        addColumnSettings(() => target.constructor, new _OneToManySetting(propertyKey, getEntity, options));
    };
}
exports.OneToMany = OneToMany;
function OneToOne(getEntity, options) {
    return (target, propertyKey) => {
        addColumnSettings(() => target.constructor, new _OneToOneSetting(propertyKey, getEntity, options));
    };
}
exports.OneToOne = OneToOne;
function ManyToOne(getEntity, options) {
    return (target, propertyKey) => {
        addColumnSettings(() => target.constructor, new _ManyToOneSetting(propertyKey, getEntity, options));
    };
}
exports.ManyToOne = ManyToOne;
function ArrayReference(getEntity, options) {
    return (target, propertyKey) => {
        addColumnSettings(() => target.constructor, new _ArrayReference(propertyKey, getEntity, options));
    };
}
exports.ArrayReference = ArrayReference;
function CreateDateColumn(options) {
    return (target, propertyKey) => {
        addColumnSettings(() => target.constructor, new _CreateDateColumnSetting(propertyKey));
    };
}
exports.CreateDateColumn = CreateDateColumn;
function UpdateDateColumn(options) {
    return (target, propertyKey) => {
        addColumnSettings(() => target.constructor, new _UpdateDateColumnSetting(propertyKey));
    };
}
exports.UpdateDateColumn = UpdateDateColumn;
function BeforeSave(options) {
    return (target, propertyKey) => {
        addHooks(() => target.constructor, new _HookFunction('beforeSave', propertyKey));
    };
}
exports.BeforeSave = BeforeSave;
function AfterSave(options) {
    return (target, propertyKey) => {
        addHooks(() => target.constructor, new _HookFunction('afterSave', propertyKey));
    };
}
exports.AfterSave = AfterSave;
function AfterLoad(options) {
    return (target, propertyKey) => {
        addHooks(() => target.constructor, new _HookFunction('afterLoad', propertyKey));
    };
}
exports.AfterLoad = AfterLoad;
function FirebaseEntity(tableName) {
    return (constructor) => {
        entityMetaInfo.push({
            tableName: tableName,
            Entity: constructor
        });
    };
}
exports.FirebaseEntity = FirebaseEntity;
// export function NestedFirebaseEntity<T>(parentEntityGetter: () => ClassType<T>, tableName: string) {
//     return (constructor: Function) => {
//         entityMetaInfo.push({
//             tableName: tableName,
//             Entity: constructor,
//             parentEntityGetter: parentEntityGetter
//         });
//     }
// }
function NestedFirebaseEntity(tableName, ...parentEntityGetters) {
    return (constructor) => {
        entityMetaInfo.push({
            tableName: tableName,
            Entity: constructor,
            parentEntityGetters: parentEntityGetters
        });
    };
}
exports.NestedFirebaseEntity = NestedFirebaseEntity;
//# sourceMappingURL=Entity.js.map